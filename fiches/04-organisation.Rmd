# Comment organiser un code `R`

## Lister les dépendances

Il est important de mettre en évidence dans le code la liste des *packages* utilisés, la définition des fonctions (si elles sont utilisées plusieurs fois dans le script) et la définition des paramètres. Cela permet de bien visualiser les *packages* chargés pour un script ainsi que l'ensemble des paramètres à éventuellement modifier/mettre à jour. 

Le code ci-dessous permet d'installer automatiquement une série de *packages* si ceux-ci ne sont pas déjà installés:

```{r, eval = FALSE}
list_packages <- c("ggplot2", "Rcpp")
new_packages <- list_packages[!(list_packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)
```

Ce code ne charge pas les packages, il faut ajouter `library(nom_du_package)` au début du code s'il est nécessaire de charger le *package* pour exécuter le code (si toutes les fonctions ont été importées sous la forme `pkg::function`, par exemple `dplyr::select`, ce n'est pas nécessaire).

## Organiser plusieurs traitements

Lorsqu'on travaille sur un traitement long, **il est en premier lieu vivement recommandé de modulariser le code avec des fonctions** (paradigme `do not repeat yourself`). Ensuite, il existe deux types d'organisations des scripts:

1. un unique fichier `maître` qui appel des fonctions qui ont été intégrées dans un package. Cette approche est la plus adéquate pour assurer la reproductibilité des traitements car les *packages* gèrent de manière explicite les relations entre les fonctions et environnements ainsi que la documentation. 
2. un fichier maître qui appelle une série de scripts qui effectuent des étapes intermédiaires, avec des tâches bien ciblées.

La première approche est plus adéquate pour un projet collaboratif ou un projet de chaîne de traitement statistique (où la reproductibilité est un impératif!). La deuxième approche peut convenir pour un projet personnel ou une étude ponctuelle. Elle nécessite néanmoins une rigueur proche de la première.

La deuxième approche prend la forme suivante:

* un script *maître*, qui définit les variables d'environnement et exécute les scripts successifs avec la commande `source`. Par exemple, il peut s'agit d'expliciter les chemins pour accéder aux données si celles-ci sont stockées dans des coffres externes au projet. Les chargements de package, via `library(.)`, peuvent prendre place dans ce script. Il convient néanmoins de rester rigoureux dans la gestion de ceux-ci car l'environnement dans lequel a été développé un script peut différer de celui dans lequel il a été exécuté. Le nom de ce script prend souvent le préfixe `0`;
* les scripts principaux qui effectuent les traitements *stricto sensu*; ces scripts sont souvent nommés avec un préfixe qui varie entre `1` et `n`, dans l'ordre d'appel (voir [Comment nommer les objets dans `R`?]) pour plus de détails sur le choix des noms);
* les scripts auxiliaires qui définissent des fonctions génériques utiles pour les traitements.

Voici un exemple de script `master`, qui définit le répertoire de travail, charge les *packages* utilisés par le projet et appelle les scripts de traitement.

```{r, eval = FALSE}

# Charger les packages du projet
library(readr)
library(dplyr)
library(ggplot2)

# Appeler les différents scripts du projet
# (présents dans le dossier D:/Mes Documents/Projet_stat/)
source("1_Import_donnees.R", encoding = "UTF-8", echo = TRUE)
source("2_Traitement_donnees.R", encoding = "UTF-8", echo = TRUE)
source("3_estimation_modele.R", encoding = "UTF-8", echo = TRUE)
source("4_Sorties_tableaux.R", encoding = "UTF-8", echo = TRUE)
source("5_Sorties_graphiques.R", encoding = "UTF-8", echo = TRUE)
```

La première approche, celle fondée sur des fonctions encapsulées dans un ou des packages, constitue une approche plus fiable pour la reproductibilité du code car elle évite les erreurs, parfois difficiles à détecter, liées aux environnements et chemin de noms des packages. La transformation de scripts modularisés en *packages* a été nettement facilité au cours des dernières années. Nous vous recommandons la dernière partie de la formation **Travail collaboratif avec R** à cet égard.

## Organiser ses tests

Il y a un sujet sur les **tests et contrôles** souvent rencontré par les statisticiens dans la rédaction de scripts. Faut-il ou non laisser dans le script les tests qui ont été effectués au cours du travail avec leurs résultats (éventuellement en commentaires donc désactivés) ?

Plusieurs éléments tendent vers une réponse négative :
* Ils sont souvent inutiles pour quelqu’un qui revient plus tard sur le script : inutile par exemple de voir que son rédacteur a regardé le nom des colonnes d’une table en sortie, compté son nombre d’observations ou regardé tel tri à plat.
* Ils rompent le rythme de lecture du script, c’est donc aussi facteur de difficulté à le lire et à comprendre sa structure.
Si l’on veut garder une trace des tests et contrôles qu’on a lancés, il faut les mettre dans un **script dédié** dans un répertoire à part. Cette pratique correspond à celle du développement de packages R, les tests étant typiquement dans un répertoire de test. Ils sont réalisés à chaque compilation du package et génèrent des erreurs ou des warnings selon ce qui est spécifié en cas de résultat non attendu. Cette approche est aussi celle du package *testthat*.

Cette pratique permet de pouvoir récupérer les tests plus tard sans encombrer la chaîne de traitement, avec deux principaux intérêts : 
*	lister les tests importants à relancer si l’on actualise le traitement ou le relance ;
*	laisser une trace des résultats méritant une attention particulière (par exemple : « oui, la détection de doublons montre qu'il y a 17 doublons dans la table, mais c'est lié au retraitement des valeurs manquantes de la variable V1 et n'est pas problématique »). 
*	pouvoir récupérer des morceaux de code pour ne pas avoir à les retaper ;

Le lien vers le script de tests peut être indiqué en en-tête du script principal (qui réalise l’étude ou le traitement).

Pour documenter ces tests, des commentaires dans le script suffisent, la documentation des tests pouvant donc rester minimale. Il est utile, sous chaque test, de mettre en commentaire aussi la date, les résultats même laconiquement, voire la décision prise suite au test. Cela peut donner un script avec plus de "texte" que de "code", ce qui n'est pas un problème en soi. 

S'il y a plusieurs phases de tests (la première a donné lieu à des premiers correctifs, la version corrigée a été testée, etc), cela donne plusieurs scripts de tests *datés*, qui peuvent être très courts pour certains.


Un test se caractérise par :
*	un input déterminé ;
*	un traitement à réaliser sur l'input ;
*	un résultat attendu ;
*	une action à générer selon la comparaison entre le résultat du traitement sur l'input et le résultat attendu.

II faut donc distinguer les tests à proprement parler et les explorations :
*	les tests à proprement parler répondent oui/non à une question bien déterminée. Si le test renvoie le résultat attendu, cela n'appelle à action, sinon il y a un correctif à faire.
*	les explorations suivent une logique plus ouverte et consistent à se donner une idée des données qu'on traite (regarder les premières lignes de la table), ou des résultats qu'on sort (regarder les ordres de grandeur dans un premier tableau qu'on a sorti). Elles ont lieu en début du travail.
On a envie de les garder car elles nous ont aidé à entrer dans le sujet, mais leur code n'est presque jamais intéressant. En revanche, il est très utile de noter précieusement et de façon synthétique leurs **conclusions notables** (par exemple, "la variable montant est en k€ et non en €", "la table T a une clef unique *toto* qui est manquante dans 1 % des cas", etc) à ne pas manquer par la suite.

Les tests et résultats d’explorations qu’on choisit de garder finalement sont à **sélectionner** rétrospectivement, pour ne garder que les éléments pertinents. En cours de travail, les tests et explorations peuvent être un joyeux fourre-tout, mais si l’on veut les valoriser, supprimer beaucoup permet de laisser un script court et ciblé sur ce qui a un intérêt.

En termes de qualité, le temps du regard rétrospectif sur le travail réalisé est fondamental. On fait ce travail rétrospectif en restructurant et commentant un script pour le rendre intelligible ; dans cette phase qui rend claires les choses, on découvre souvent des oublis ou des erreurs dans ce qui été fait au fil de l'eau. Ce travail rétrospectif s’opère aussi lors de l’écriture d’une documentation. La documentation d’un processus est presque aussi importante que le processus lui-même. C'est l'un des sujets centraux de la _qualité_ d'un travail statistique.

## Titres

**Il est recommandé de mettre des titres aux sous-parties du script** pour plus de lisibilité, de la forme suivante:
```{r eval = F}
# Titre 1 -------------------------------------
# Titre 2 =====================================

# ou bien 

##### Titre 1 ---------------------------------
##### Titre 2 =================================
```

Il est alors possible de se rendre directement à une section à partir de la fenêtre script (en bas avec les flêches).

## Commentaires

**Il est essentiel de commenter son code pour qu'il puisse être aisément repris et compris par autrui ou par soi-même dans le futur.** Il faut veiller à ce que les commentaires soient clairs et relativement courts.

## Documenter les fonctions

**La documentation des fonctions utilisées est fondamentale pour assurer la reproductibilité du code et la possibilité d'évolutions futures.** Que l'on travaille seul ou en équipe, documenter les fonctions de cette manière réduit les risques d'oubli ou de confusion. Documenter une fonction consiste, en premier lieu, à expliquer l'objet de celle-ci, de manière succincte ou détaillée, les paramètres autorisés et le résultat. `Roxygen2` propose de nombreux tags pour documenter de manière plus détaillée une fonction, une documentation plus abondante est disponible [ici](http://r-pkgs.had.co.nz/man.html).

**Une bonne pratique est de documenter les fonctions selon le standard `Roxygen2`** qui est un *package* proposant des tags standardisés `@` pour documenter une fonction. Les documentations `Roxygen2` peuvent être reconnues grâce à la balise `#'`. Dans le cadre du développement d'un *package*, cela permet de générer les documentations accessibles en tapant `?*`.

```{r, eval = FALSE}
#' Add together two numbers.
#' 
#' @param x A number.
#' @param y A number.
#' @return The sum of \code{x} and \code{y}.
#' @examples
#' add(1, 1)
#' add(10, 1)
add <- function(x, y) {
  x + y
}
```

La documentation d'un *package* est une étape essentielle, mais elle ne se suffit pas à elle-même. Pour le développement de packages, il est important également d'avoir recours à des tests unitaires afin d'assurer la fiabilité du *package* tout au long du développement.

## Définition des paramètres

Il est recommandé de mettre les données brutes utilisées dans un calcul dans des paramètres en début de script, afin de faciliter la reprise du code par autrui. Par exemple, si l'on utilise un paramètre fiscal comme le taux d'une taxe:

```{r eval = F}
# Avec la liste des paramètres en début de code
taux_taxe <- 0.0627
assiette_taxe <- 1

# ...
# On utilise directement la variable taux_taxe dans le calcul.
impot <- assiette_taxe * taux_taxe
```

Les paramètres doivent être définis en début de script, y compris s'ils sont définis à partir d'un fichier Excel importé, afin de pouvoir les visualiser rapidement pour éventuellement les modifier/actualiser.

## Chemins

* Si le code appartient à un `RProject`, il est préférable de définir les chemins de manière relative sur tous les éléments qui appartiennent au projet. Par exemple, si les données sont dans le dossier `C:/MesDocuments/monprojet/data`, un projet dans `C:/MesDocuments/monprojet` permettra de faire seulement référence à `./data`;
* Sinon, il est recommandé de définir le chemin principal en début de code avec `chemin_principal <- "C:/MesDocuments/monprojet"` et `setwd(chemin_principal)`, de façon à définir ensuite des chemins relatifs à ce chemin principal.

```{r eval = F}
# Avec la liste des chemins en début de code

chemin_donnees <- "I:/ECHANGE/.../"

# ...

# Quand on veut appeler le fichier
load(paste0(chemin_donnees, "nom_script.R"))

```

L'utilisation des projets *Rstudio* est une pratique à privilégier car elle assure une meilleure reproducibilité du code.
